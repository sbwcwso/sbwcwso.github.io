(window.webpackJsonp=window.webpackJsonp||[]).push([[402],{1088:function(e,a,l){"use strict";l.r(a);var t=l(12),r=Object(t.a)({},(function(){var e=this,a=e.$createElement,l=e._self._c||a;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h1",{attrs:{id:"173-虚拟内存系统如何支持用户应用程序"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#173-虚拟内存系统如何支持用户应用程序"}},[e._v("#")]),e._v(" 17.3 虚拟内存系统如何支持用户应用程序")]),e._v(" "),l("p",[e._v("有关实现，有两个方面较为有趣。")]),e._v(" "),l("p",[e._v("第一个是虚拟内存系统为了支持这里的特性，具体会发生什么？这里我们只会讨论最重要的部分，并且它也与即将开始的mmap lab有一点相关，因为在mmap lab中你们将要做类似的事情。在现代的Unix系统中，地址空间是由硬件Page Table来体现的，在Page Table中包含了地址翻译。但是通常来说，地址空间还包含了一些操作系统的数据结构，这些数据结构与任何硬件设计都无关，它们被称为Virtual Memory Areas（VMAs）。VMA会记录一些有关连续虚拟内存地址段的信息。在一个地址空间中，可能包含了多个section，每一个section都由一个连续的地址段构成，对于每个section，都有一个VMA对象。连续地址段中的所有Page都有相同的权限，并且都对应同一个对象VMA（例如一个进程的代码是一个section，数据是另一个section，它们对应不同的VMA，VMA还可以表示属于进程的映射关系，例如下面提到的Memory Mapped File）。")]),e._v(" "),l("p",[l("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28798%29.png",alt:""}})]),e._v(" "),l("p",[e._v("举个例子，如果进程有一个Memory Mapped File，那么对于这段地址，会有一个VMA与之对应，VMA中会包含文件的权限，以及文件本身的信息，例如文件描述符，文件的offset等。在接下来的mmap lab中，你们将会实现一个非常简单版本的VMA，并用它来实现针对文件的mmap系统调用。你可以在VMA中记录mmap系统调用参数中的文件描述符和offset。")]),e._v(" "),l("p",[e._v("第二个部分我们了解的就不多了，它或许值得仔细看一下，也就是User level trap是如何实现的？我们假设一个PTE被标记成invalid或者只读，而你想要向它写入数据。这时，CPU会跳转到kernel中的固定程序地址，也就是XV6中的trampoline代码（注，详见6.2）。kernel会保存应用程序的状态，在XV6中是保存到trapframe。之后再向虚拟内存系统查询，现在该做什么呢？虚拟内存系统或许会做点什么，例如在lazy lab和copy-on-write lab中，trap handler会查看Page Table数据结构。而在我们的例子中会查看VMA，并查看需要做什么。举个例子，如果是segfault，并且应用程序设置了一个handler来处理它，那么")]),e._v(" "),l("ul",[l("li",[e._v("segfault事件会被传播到用户空间")]),e._v(" "),l("li",[e._v("并且通过一个到用户空间的upcall在用户空间运行handler")]),e._v(" "),l("li",[e._v("在handler中或许会调用mprotect来修改PTE的权限")]),e._v(" "),l("li",[e._v("之后handler返回到内核代码")]),e._v(" "),l("li",[e._v("最后，内核再恢复之前被中断的进程。")])]),e._v(" "),l("p",[l("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28788%29.png",alt:""}})]),e._v(" "),l("p",[e._v("当内核恢复了中断的进程时，如果handler修复了用户程序的地址空间，那么程序指令可以继续正确的运行，如果哪里出错了，那么会通过trap再次回到内核，因为硬件还是不能翻译特定的虚拟内存地址。")]),e._v(" "),l("blockquote",[l("p",[e._v("学生提问：当我们允许用户针对Page Fault来运行handler代码时，这不会引入安全漏洞吗？")]),e._v(" "),l("p",[e._v("Frans教授：这是个很好的问题。会有安全问题吗？你们怎么想的？这会破坏User/kernel或者不同进程之间的隔离性吗？或者从另一个角度来说，你的问题是sigalarm会破坏隔离性吗？")]),e._v(" "),l("p",[e._v("当我们执行upcall的时候，upcall会走到设置了handler的用户空间进程中，所以handler与设置了它的应用程序运行在相同的context，相同的Page Table中。所以handler唯一能做的事情就是影响那个应用程序，并不能影响其他的应用程序，因为它不能访问其他应用程序的Page Table，或者切换到其他应用程序的Page Table。所以这里还好。")]),e._v(" "),l("p",[e._v("当然，如果handler没有返回，或者做了一些坏事，最终内核还是会杀掉进程。所以唯一可能出错的地方就是进程伤害了自己，但是它不能伤害任何其他进程。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);