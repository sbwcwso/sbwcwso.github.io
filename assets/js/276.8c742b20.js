(window.webpackJsonp=window.webpackJsonp||[]).push([[276],{823:function(t,s,a){"use strict";a.r(s);var v=a(12),n=function(t){t.options.__data__block__={markmap_1a96284d:"- [路由算法](#路由算法)\n  - [网络抽象](#网络抽象)\n  - [路由算法分类](#路由算法分类)\n  - [链路状态路由算法](#链路状态路由算法)\n  - [距离向量路由算法](#距离向量路由算法)\n  - [层次路由](#层次路由)"}},_=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"路由算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由算法"}},[t._v("#")]),t._v(" 路由算法")]),t._v(" "),a("Markmap",{attrs:{id:"markmap_1a96284d",code:t.$dataBlock.markmap_1a96284d}}),a("ul",[a("li",[t._v("路由算法(协议)确定去往目的网络的最佳路径")]),t._v(" "),a("li",[t._v("转发表确定在本路由器如何转发分组")])]),t._v(" "),a("h2",{attrs:{id:"网络抽象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络抽象"}},[t._v("#")]),t._v(" 网络抽象")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("图")]),t._v(" "),a("ul",[a("li",[t._v("路由器被抽象为结点")]),t._v(" "),a("li",[t._v("路由器之间有物理链路相连，则抽象为边")])])]),t._v(" "),a("li",[a("p",[t._v("图中的权值")]),t._v(" "),a("ul",[a("li",[t._v("费用\n"),a("ul",[a("li",[t._v("广义上可称为距离")])])])])])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("关键问题")]),t._v(" "),a("ul",[a("li",[t._v("源到目的（如u到z）的最小费用路径是什么")])])]),t._v(" "),a("h2",{attrs:{id:"路由算法分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由算法分类"}},[t._v("#")]),t._v(" 路由算法分类")]),t._v(" "),a("div",{staticClass:"custom-block note"},[a("p",{staticClass:"custom-block-title"},[t._v("静态路由与动态路由")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("静态路由")]),t._v(" "),a("ul",[a("li",[t._v("手工配置")]),t._v(" "),a("li",[t._v("路由更新慢")]),t._v(" "),a("li",[t._v("优先级高")])])])]),t._v(" "),a("li",[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("动态路由")]),t._v(" "),a("ul",[a("li",[t._v("定期更新")]),t._v(" "),a("li",[t._v("及时响应链路费用或网络拓扑变化")])])])])])]),t._v(" "),a("div",{staticClass:"custom-block note"},[a("p",{staticClass:"custom-block-title"},[t._v("全局信息 与 分散信息")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("基于全局信息的路由算法")]),t._v(" "),a("ul",[a("li",[t._v("所有路由器掌握完整的网络拓扑和链路费用信息")]),t._v(" "),a("li",[t._v("例如：链路状态(LS)路由算法")])])])]),t._v(" "),a("li",[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("基于分散信息的路由算法")]),t._v(" "),a("ul",[a("li",[t._v("路由器只掌握物理相连的邻居以及链路费用")]),t._v(" "),a("li",[t._v("邻居间信息交换、运算的迭代过程")]),t._v(" "),a("li",[t._v("例如：距离向量(DV)路由算法")])])])])])]),t._v(" "),a("h2",{attrs:{id:"链路状态路由算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链路状态路由算法"}},[t._v("#")]),t._v(" 链路状态路由算法")]),t._v(" "),a("div",{staticClass:"custom-block note"},[a("p",{staticClass:"custom-block-title"},[a("code",[t._v("Dijkstra")]),t._v(" 算法")]),t._v(" "),a("ul",[a("li",[t._v("所有结点(路由器)掌握网络拓扑和链路费用\n"),a("ul",[a("li",[t._v('通过"链路状态广播"')]),t._v(" "),a("li",[t._v("所有结点拥有相同信息")])])]),t._v(" "),a("li",[t._v('计算从一个结点("源")到达所有其他结点的最短路径\n'),a("ul",[a("li",[t._v("获得该结点的转发表")])])]),t._v(" "),a("li",[t._v("迭代: "),a("code",[t._v("k")]),t._v(" 次迭代后，得到到达 "),a("code",[t._v("k")]),t._v(" 个目的结点的最短路径")])])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("相关符号")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("c(x,y)")]),t._v(" "),a("ul",[a("li",[t._v("结点 "),a("code",[t._v("x")]),t._v(" 到结点 "),a("code",[t._v("y")]),t._v(" 链路费用")]),t._v(" "),a("li",[t._v("如果 "),a("code",[t._v("x")]),t._v(" 和 "),a("code",[t._v("y")]),t._v(" 不直接相连，则 "),a("code",[t._v("=∞")])])])]),t._v(" "),a("li",[a("code",[t._v("D(v)")]),t._v(" "),a("ul",[a("li",[t._v("从源到目的 "),a("code",[t._v("v")]),t._v(" 的当前路径费用值")])])]),t._v(" "),a("li",[a("code",[t._v("p(v)")]),t._v(" "),a("ul",[a("li",[t._v("沿从源到 "),a("code",[t._v("v")]),t._v(" 的当前路径， "),a("code",[t._v("v")]),t._v(" 的前序结点")])])]),t._v(" "),a("li",[a("code",[t._v("N’")]),t._v(" "),a("ul",[a("li",[t._v("已经找到最小费用路径的结点集合")])])])])]),t._v(" "),a("div",{staticClass:"custom-block note"},[a("p",{staticClass:"custom-block-title"},[t._v("算法描述")]),t._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[t._v("初始化"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\nN' "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("u"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" 所有结点 v\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" v毗邻u\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" then "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("D")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("c")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("u"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("D")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ∞\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v(" Loop\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),t._v(" 找出不在 N’中的w ，满足"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("D")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("w"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("最小\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" 将w加入N'\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),t._v(" 更新w的所有不在N’中的邻居v的"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("D")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("D")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("min")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("D")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("D")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("w"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("c")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("w"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("13")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*到达v的新费用或者是原先到达v的费用，或者是\n14 已知的到达w的最短路径费用加上w到v的费用 */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("15")]),t._v(" until 所有结点在N’中\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br")])])]),t._v(" "),a("ul",[a("li",[t._v("最短路径树")])]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("存在震荡(oscillations)可能")])]),t._v(" "),a("h2",{attrs:{id:"距离向量路由算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#距离向量路由算法"}},[t._v("#")]),t._v(" 距离向量路由算法")]),t._v(" "),a("div",{staticClass:"custom-block note"},[a("p",{staticClass:"custom-block-title"},[t._v("Bellman-Ford 方程(动态规划)")]),t._v(" "),a("ul",[a("li",[t._v("路由器不需知道整个网络拓扑")]),t._v(" "),a("li",[t._v("结点获得最短路径的下一跳, 该信息用于转发表中")])])]),t._v(" "),a("div",{staticClass:"custom-block note"},[a("p",{staticClass:"custom-block-title"},[t._v("算法实现")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("异步迭代")])]),t._v(" "),a("li",[a("p",[t._v("分布式")])])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("计算示例")])]),t._v(" "),a("div",{staticClass:"custom-block note"},[a("p",{staticClass:"custom-block-title"},[t._v("链路费用变化")]),t._v(" "),a("ul",[a("li",[t._v("结点检测本地链路费用变化")]),t._v(" "),a("li",[t._v("更新路由信息，重新计算距离向量")]),t._v(" "),a("li",[t._v("如果DV改变，通告所有邻居")])])]),t._v(" "),a("ul",[a("li",[t._v("好消息与坏消息\n"),a("ul",[a("li",[t._v('对坏消息, 环路中可能存在 "无穷计数" 的问题\n'),a("ul",[a("li",[t._v("错误的认为通过 "),a("code",[t._v("z")]),t._v(" 到达 "),a("code",[t._v("x")]),t._v(" 的距离为 "),a("code",[t._v("5")])]),t._v(" "),a("li",[t._v("会持续震荡, 收敛较慢")])])])])])]),t._v(" "),a("div",{staticClass:"custom-block note"},[a("p",{staticClass:"custom-block-title"},[t._v("无穷计数问题的消除方法")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("毒性逆转")])])]),t._v(" "),a("li",[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("定义最大度量")]),t._v(" "),a("ul",[a("li",[t._v("跳步，在有限的交换过程中达到收敛")])])])])])]),t._v(" "),a("h2",{attrs:{id:"层次路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#层次路由"}},[t._v("#")]),t._v(" 层次路由")]),t._v(" "),a("ul",[a("li",[t._v("聚合路由器为一个区域：自治系统AS(autonomous systems)")]),t._v(" "),a("li",[t._v("同一AS内的路由器运行相同的路由协议(算法)\n"),a("ul",[a("li",[t._v('自治系统内部路由协议("intra-AS" routing protocol)')])])]),t._v(" "),a("li",[t._v("不同自治系统内的路由器可以运行不同的AS内部路由协议")])])],1)}),[],!1,null,null,null);"function"==typeof n&&n(_);s.default=_.exports}}]);