(window.webpackJsonp=window.webpackJsonp||[]).push([[386],{1074:function(t,e,r){"use strict";r.r(e);var s=r(12),o=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"156-file-system-recovering"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#156-file-system-recovering"}},[t._v("#")]),t._v(" 15.6 File system recovering")]),t._v(" "),r("p",[t._v("接下来我们看一下发生在XV6的启动过程中的文件系统的恢复流程。当系统crash并重启了，在XV6启动过程中做的一件事情就是调用initlog函数。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28643%29.png",alt:""}})]),t._v(" "),r("p",[t._v("initlog基本上就是调用recover_from_log函数。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28651%29.png",alt:""}})]),t._v(" "),r("p",[t._v("recover_from_log先调用read_head函数从磁盘中读取header，之后调用install_trans函数。这个函数之前在commit函数中也调用过，它就是读取log header中的n，然后根据n将所有的log block拷贝到文件系统的block中。recover_from_log在最后也会跟之前一样清除log。")]),t._v(" "),r("p",[t._v("这就是恢复的全部流程。如果我们在install_trans函数中又crash了，也不会有问题，因为之后再重启时，XV6会再次调用initlog函数，再调用recover_from_log来重新install log。如果我们在commit之前crash了多次，在最终成功commit时，log可能会install多次。")]),t._v(" "),r("blockquote",[r("p",[t._v("学生提问：如果一个进程向磁盘写了一些数据，但是在commit之前进程出现了故障，假设故障之后进程退出了，这样会有问题吗？")]),t._v(" "),r("p",[t._v("Frans教授：简单回答是没问题，因此磁盘不会被更新，所以效果就像文件系统操作没有发生过一样。并且进程并不能在故障后恢复，唯一能在故障之后还能保持的是保存在磁盘中的状态。（注，应该是没有理解问题。进程通过write系统调用成功写入的数据，就算在成功落盘之前进程异常退出了，内核还是会写入到磁盘中，前提是内核还在运行。）")])])])}),[],!1,null,null,null);e.default=o.exports}}]);