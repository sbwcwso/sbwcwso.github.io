(window.webpackJsonp=window.webpackJsonp||[]).push([[436],{1122:function(t,e,a){"use strict";a.r(e);var p=a(12),c=Object(p.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"212-二层网络-----ethernet"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#212-二层网络-----ethernet"}},[t._v("#")]),t._v(" 21.2 二层网络 --- Ethernet")]),t._v(" "),a("p",[t._v("让我从最底层开始，我们先来看一下一个以太网packet的结构是什么。当两个主机非常靠近时，或许是通过相同的线缆连接，或许连接在同一个wifi网络，或许连接到同一个以太网交换机。当局域网中的两个主机彼此间要通信时，最底层的协议是以太网协议。你可以认为Host1通过以太网将Frame发送给Host2。Frame是以太网中用来描述packet的单词，本质上这就是两个主机在以太网上传输的一个个的数据Byte。以太网协议会在Frame中放入足够的信息让主机能够识别彼此，并且识别这是不是发送给自己的Frame。每个以太网packet在最开始都有一个Header，其中包含了3个数据。Header之后才是payload数据。Header中的3个数据是：目的以太网地址，源以太网地址，以及packet的类型。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28428%29.png",alt:""}})]),t._v(" "),a("p",[t._v("每一个以太网地址都是48bit的数字，这个数字唯一识别了一个网卡。packet的类型会告诉接收端的主机该如何处理这个packet。接收端主机侧更高层级的网络协议会按照packet的类型检查并处理以太网packet中的payload。")]),t._v(" "),a("p",[t._v("整个以太网packet，包括了48bit+48bit的以太网地址，16bit的类型，以及任意长度的payload这些都是通过线路传输。除此之外，虽然对于软件来说是不可见的，但是在packet的开头还有被硬件识别的表明packet起始的数据（注，Preamble + SFD），在packet的结束位置还有几个bit表明packet的结束（注，FCS）。packet的开头和结束的标志不会被系统内核所看到，其他的部分会从网卡送到系统内核。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28373%29.png",alt:""}})]),t._v(" "),a("p",[t._v("如果你们查看了这门课程的最后一个lab，你们可以发现我们提供的代码里面包括了一些新的文件，其中包括了kernel/net.h，这个文件中包含了大量不同网络协议的packet header的定义。上图中的代码包含了以太网协议的定义。我们提供的代码使用了这里结构体的定义来解析收到的以太网packet，进而获得目的地址和类型值（注，实际中只需要对收到的raw data指针强制类型转换成结构体指针就可以完成解析）。")]),t._v(" "),a("blockquote",[a("p",[t._v("学生提问：硬件用来识别以太网packet的开头和结束的标志是不是类似于lab中的End of Packets？")]),t._v(" "),a("p",[t._v("Robert教授：并不是的，EOP是帮助驱动和网卡之间通信的机制。这里的开头和结束的标志是在线缆中传输的电信号或者光信号，这些标志位通常在一个packet中是不可能出现的。以结束的FCS为例，它的值通常是packet header和payload的校验和，可以用来判断packet是否合法。")])]),t._v(" "),a("p",[t._v("有关以太网48bit地址，是为了给每一个制造出来的网卡分配一个唯一的ID，所以这里有大量的可用数字。这里48bit地址中，前24bit表示的是制造商，每个网卡制造商都有自己唯一的编号，并且会出现在前24bit中。后24bit是由网卡制造商提供的任意唯一数字，通常网卡制造商是递增的分配数字。所以，如果你从一个网卡制造商买了一批网卡，每个网卡都会被写入属于自己的地址，并且如果你查看这些地址，你可以发现，这批网卡的高24bit是一样的，而低24bit极有可能是一些连续的数字。")]),t._v(" "),a("p",[t._v("虽然以太网地址是唯一的，但是出了局域网，它们对于定位目的主机的位置是没有帮助的。如果网络通信的目的主机在同一个局域网，那么目的主机会监听发给自己的地址的packet。但是如果网络通信发生在两个国家的主机之间，你需要使用一个不同的寻址方法，这就是IP地址的作用。")]),t._v(" "),a("p",[t._v("在实际中，你可以使用tcpdump来查看以太网packet。这将会是lab的一部分。下图是tcpdump的一个输出：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28391%29.png",alt:""}})]),t._v(" "),a("p",[t._v("tcpdump输出了很多信息，其中包括：")]),t._v(" "),a("ul",[a("li",[t._v("接收packet的时间")]),t._v(" "),a("li",[t._v("第一行的剩下部分是可读的packet的数据")]),t._v(" "),a("li",[t._v("接下来的3行是收到packet的16进制数")])]),t._v(" "),a("p",[t._v("如果按照前面以太网header的格式，可以发现packet中：")]),t._v(" "),a("ul",[a("li",[t._v("前48bit是一个广播地址，0xffffffffffff。广播地址是指packet需要发送给局域网中的所有主机。")]),t._v(" "),a("li",[t._v("之后的48bit是发送主机的以太网地址，我们并不能从这个地址发现什么，实际上这个地址是运行在QEMU下的XV6生成的地址，所以地址中的前24bit并不是网卡制造商的编号，而是QEMU编造的地址。")]),t._v(" "),a("li",[t._v("接下来的16bit是以太网packet的类型，这里的类型是0x0806，对应的协议是ARP。")]),t._v(" "),a("li",[t._v("剩下的部分是ARP packet的payload。")])])])}),[],!1,null,null,null);e.default=c.exports}}]);