(window.webpackJsonp=window.webpackJsonp||[]).push([[438],{1123:function(e,t,a){"use strict";a.r(t);var r=a(12),p=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"214-三层网络-----internet"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#214-三层网络-----internet"}},[e._v("#")]),e._v(" 21.4 三层网络 --- Internet")]),e._v(" "),a("p",[e._v("Ethernet header足够在一个局域网中将packet发送到一个host。如果你想在局域网发送一个IP packet，那么你可以使用ARP获得以太网地址。但是IP协议更加的通用，IP协议能帮助你向互联网上任意位置发送packet。下图是一个IP packet的header，你们可以在lab配套的代码中的net.h文件找到。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28425%29.png",alt:""}})]),e._v(" "),a("p",[e._v("如果IP packet是通过以太网传输，那么你可以看到，在一个以太网packet中，最开始是目的以太网地址，源以太网地址，以太网类型是0x0800，之后是IP header，最后是IP payload。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28377%29.png",alt:""}})]),e._v(" "),a("p",[e._v("在一个packet发送到世界另一端的网络的过程中，IP header会被一直保留，而Ethernet header在离开本地的以太网之后会被剥离。或许packet在被路由的过程中，在每一跳（hop）会加上一个新的Ethernet header。但是IP header从源主机到目的主机的过程中会一直保留。")]),e._v(" "),a("p",[e._v("IP header具有全局的意义，而Ethernet header只在单个局域网有意义。所以IP header必须包含足够的信息，这样才能将packet传输给互联网上遥远的另一端。对于我们来说，关键的信息是三个部分，目的IP地址（ip_dst），源IP地址（ip_src）和协议（ip_p）。目的IP地址是我们想要将packet送到的目的主机的IP地址。地址中的高bit位是网络号，它会帮助路由器完成路由。IP header中的协议字段会告诉目的主机如何处理IP payload。")]),e._v(" "),a("p",[e._v("如果你们看到过MIT的IP地址，你们可以看到IP地址是18.x.x.x，虽然最近有些变化，但是在很长一段时间18是MIT的网络号。所以MIT的大部分主机的IP地址最高字节就是18。全世界的路由器在看到网络号18的时候，就知道应该将packet路由到离MIT更近的地方。")]),e._v(" "),a("p",[e._v("接下来我们看一下包含了IP packet的tcpdump输出。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28390%29.png",alt:""}})]),e._v(" "),a("p",[e._v("因为这个IP packet是在以太网上传输，所以它包含了以太网header。呃……，实际上这个packet里面有点问题，我不太确定具体的原因是什么，但是Ethernet header中目的以太网地址不应该是全f，因为全f是广播地址，它会导致packet被发送到所有的主机上。一个真实网络中两个主机之间的packet，不可能出现这样的以太网地址。所以我提供的针对network lab的方案，在QEMU上运行有点问题。不管怎么样，我们可以看到以太网目的地址，以太网源地址，以及以太网类型0x0800。0x0800表明了Ethernet payload是一个IP packet。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28429%29.png",alt:""}})]),e._v(" "),a("p",[e._v("IP header的长度是20个字节，所以中括号内的是IP header，")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28401%29.png",alt:""}})]),e._v(" "),a("p",[e._v("从后向前看：")]),e._v(" "),a("ul",[a("li",[e._v("目的IP地址是0x0a000202，也就是10.0.2.2。")]),e._v(" "),a("li",[e._v("源IP地址是0x0a00020f，也就是10.0.2.15。")]),e._v(" "),a("li",[e._v("再向前有16bit的checksum，也就是0x3eae。IP相关的软件需要检查这个校验和，如果结果不匹配应该丢包。")]),e._v(" "),a("li",[e._v("再向前一个字节是protocol，0x11对应的是10进制17，表明了下一层协议是UDP")]),e._v(" "),a("li",[e._v("其他的就是我们不太关心的一些字段了，例如packet的长度。")])]),e._v(" "),a("p",[e._v("IP header中的protocol字段告诉了目的主机的网络协议栈，这个packet应该被UDP软件处理。")])])}),[],!1,null,null,null);t.default=p.exports}}]);