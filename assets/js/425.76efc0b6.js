(window.webpackJsonp=window.webpackJsonp||[]).push([[425],{1111:function(t,s,e){"use strict";e.r(s);var v=e(12),i=Object(v.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"202-高级编程语言实现操作系统的优劣势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#202-高级编程语言实现操作系统的优劣势"}},[t._v("#")]),t._v(" 20.2 高级编程语言实现操作系统的优劣势")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28490%29.png",alt:""}})]),t._v(" "),e("p",[t._v("高级编程语言吸引人的一个原因是它提供了memory-safety，所以上一节中CVEs提到的所有Bugs，都将不再存在。要么当它们发生时程序运行时会检查数组是否越界，如果越界了就panic；要么高级编程语言不允许你写出引起Bug的代码，所以这些问题完全不可能出现。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28298%29.png",alt:""}})]),t._v(" "),e("p",[t._v("当然，高级编程语言还有一些其他的优点：")]),t._v(" "),e("ul",[e("li",[t._v("首先是Type safety，类型安全")]),t._v(" "),e("li",[t._v("通过GC实现了自动的内存管理，所以free更容易了，你都不用去考虑它，GC会为你完成所有的内存释放工作")]),t._v(" "),e("li",[t._v("对并发更友好")]),t._v(" "),e("li",[t._v("有更好的抽象，接口和类等面向对象的语法使得你可以写出更加模块化的代码")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28440%29.png",alt:""}})]),t._v(" "),e("p",[t._v("高级编程语言有这么多优势，你不禁会想它有哪些缺点呢？为什么XV6或者Linux没有用Java，Golang，Python来写？")]),t._v(" "),e("p",[t._v("这里的原因是高级编程语言通常有更差的性能。高级编程语言通常都有一些额外的代价，这被称为High Level Language Tax。")]),t._v(" "),e("ul",[e("li",[t._v("比如说在索引一个数组元素时检查数据边界，比如说检查空指针，比如说类型转换。")]),t._v(" "),e("li",[t._v("除此之外，GC也不是没有代价的，需要花费一些时间来跟踪哪些对象可以被释放。")])]),t._v(" "),e("p",[t._v("除了性能之外，高级编程语言与内核编程本身不兼容。")]),t._v(" "),e("ul",[e("li",[t._v("比如说高级编程语言没有直接访问内存的能力，因为这从原则上违反了Type safety。")]),t._v(" "),e("li",[t._v("高级编程语言不能集成汇编语言，而在内核中的一些场景你总是需要一些汇编程序，比如说两个线程的context switching，或者系统启动")]),t._v(" "),e("li",[t._v("编程语言本身支持的并发与内核需要的并发并不一致，比如我们在调度线程的时候，一个线程会将锁传递给另一个线程。一些并发管理模式在用户程序中不太常见，但是在内核中会出现。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28780%29.png",alt:""}})]),t._v(" "),e("p",[t._v("今天论文的目标是能够测量出高级编程语言的优劣势，并从safety，programmability和性能损失角度，探索使用高级编程语言而不是C语言实现内核的效果。")]),t._v(" "),e("p",[t._v("当然，为了做到这一点，你需要在一个产品级的内核上做实验，而不是在XV6上。XV6现在是由C语言写的很慢的内核，如果你用Golang也写了个很慢的内核，这不能说明C还是Golang更快，这只能说明XV6很慢。所以，你会想要在一个为高性能而设计的内核中完成这里的测量。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28812%29.png",alt:""}})]),t._v(" "),e("p",[t._v("很奇怪之前并没有一个论文完成了这里的测量。有很多论文研究了在用户程序中高级编程语言的优劣势，但是你知道的，内核与用户程序还是很不一样的，比如内核中需要有更小心的内存管理，内核中的并发或许会略有不同。所以，现在我们想要在内核中而不是用户程序中完成分析，而我们并没有找到之前的任何论文真正做了这个工作。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%2831%29.png",alt:""}})]),t._v(" "),e("p",[t._v("之前的确有很多内核是用高级编程语言写的，这里有很长的历史，甚至可以回溯到最早的计算机中。但是最近的一些基于高级编程语言的内核并不是为了评估High Level Language Tax，而是为了探索新的内核设计和新的内核架构，所以这些内核并没有在保持结构相同的同时，直接对比C语言内核。只有保持系统结构相同，你才可以真正的关注语言本身，而不是一些其他的问题。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28840%29.png",alt:""}})]),t._v(" "),e("p",[t._v("为什么没有很多论文做这样的对比测试？一个原因可能是这里的工作有点棘手。如果你想得到正确的结果，你需要与产品级别的C内核进行对比，例如Linux，Windows等等。同时，你也需要构建一个产品级别的内核。很明显，这对于一个小的团队来说很难，因为有许多许多的Linux开发人员日复一日做了许多许多的更新才创造了Linux，所以很难用高级编程语言实现同样的功能并构建同样的内核，所以我们这里会构建一个功能稍微少的系统内核。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/image%20%28861%29.png",alt:""}})]),t._v(" "),e("p",[t._v("所以我们能做到的最好情况是：")]),t._v(" "),e("ul",[e("li",[t._v("用高级编程语言构建内核")]),t._v(" "),e("li",[t._v("保留与Linux中最重要的部分对等的功能")]),t._v(" "),e("li",[t._v("优化性能使得其与Linux基本接近，即使这里的功能与Linux并不完全一致，但是我们至少可以将它们拉到一个范围内")]),t._v(" "),e("li",[t._v("最后我们就可以测量高级编程语言的优劣")])]),t._v(" "),e("p",[t._v("当然，这种方法的风险在于我们构建的内核与Linux还是略有不同，它不会与Linux完全一样，所以在得出结论时需要非常小心。这就是为什么不能对论文提出的问题（注，也就是应该使用什么样的编程语言实现操作系统）给出一个十分清晰的答案的原因。尽管如此，我们还是可以期望更深入的了解这个问题，而不是完全不知道它的内容。")]),t._v(" "),e("p",[t._v("以上就是论文的背景，以及为什么很少有人会做同样的工作的原因。")])])}),[],!1,null,null,null);s.default=i.exports}}]);