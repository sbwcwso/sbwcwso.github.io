---
title: 控制流
date: 2021-04-14 10:49:50
permalink: /pages/1bdb27/
categories: 
  - 汇编语言
tags: 
  - null
author: 
  name: 木子识时务
  link: https://github.com/sbwcwso
editLink: true
---

# 80x86 汇编与 C 语言 -- 控制流


```markmap
- [80x86 汇编与 C 语言 -- 控制流](#80x86-汇编与-c-语言----控制流)
  - [汇编程序员眼中的系统结构(部分)](#汇编程序员眼中的系统结构部分)
  - [条件码](#条件码)
  - [比较指令](#比较指令)
  - [测试 (Test) 指令](#测试-test-指令)
  - [读取条件码](#读取条件码)
      - [x86-64 下的读取条件码](#x86-64-下的读取条件码)
  - [跳转指令](#跳转指令)
    - [微体系结构背景](#微体系结构背景)
  - [条件传送指令](#条件传送指令)
    - [局限性](#局限性)
  - [循环语句](#循环语句)
    - [do-while 形式](#do-while-形式)
    - [Jump-to-Middle 模式](#jump-to-middle-模式)
    - [微体系结构背景](#微体系结构背景-1)
  - [Switch 语句](#switch-语句)
```

---

## 汇编程序员眼中的系统结构(部分)

<!--sec data-title="示意图" data-id="section20210414105330" data-show=true data-collapse=true ces-->
![20210414105348-2021-04-14-10-53-48](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414105348-2021-04-14-10-53-48.png)

* 反映了当前执行程序的信息
  * 数据
  * 指令地址
  * 运行栈地址
  * 条件码
<!--endsec-->

## 条件码

* 条件码由**算术指令隐含设置**
  * 如：`addl Src,Dest`， `addq Src,Dest`
  * 类似的C语言表达式: `t=a+b` (`a=Src, b = Dest`)

* 四个条件码
  * CF进位标志 (Carry)
    * 可用于检测无符号整数运算的溢出
  * SF 符号位 (Sign)
    * 如果 `t < 0`， 那么 `SF=1`; 否则 `SF=0`
  * ZF Zero Flag
    * 如果 `t == 0`，那么 `ZF=1`; 否则 `ZF=0`
  * OF 溢出标志 (Overflow)
    * 如果补码运算溢出，那么 `OF=1` (即带符号整数运算 )
    * 补码溢出的判断条件
    * `(a>0 && b>0 && t<0) || (a<0 && b<0 && t>=0)`

## 比较指令

`cmp1 Src2 Src1`  &nbsp;&nbsp;&nbsp;&nbsp;  `cmpq Src2, Src1`

* `cmpl b,a` 类似于计算 `a-b` (但是不改变目的操作数)
* 如果向最高位有借位，那么 `CF=1`; 否则 `CF=0`
  * 可用于无符号数的比较
* 如果 `a == b`，那么 `ZF=1`; 否则 `ZF=0`
* 如果 `(a - b) < 0`(指结果的最高位为 `1`)，那么 `SF=1`; 否则 `SF=0`
  * 即运算后若结果最高位为 `1`，那么 `SF=1`; 否则为 `0`
* 如果补码运算溢出，那么 `OF=1`
  * `(a>0 && b<0 && (a-b)<0) || (a<0 && b>0 && (a-b)>0)`

## 测试 (Test) 指令

`testl Src2 Src1`  &nbsp;&nbsp;&nbsp;&nbsp;  `testq Src2, Src1`

* 计算 `Src1 & Src2` 并设置相应的条件码，但是不改变目的操作数
  * 如果 `a&b == 0`，那么 `ZF=1`; 否则为 `0`
  * 如果 `a&b < 0` ，那么 `SF=1`; 否则为 `0`
  * 即运算后结果最高位为 `1`，那么`SF=1`; 否则为`0`
* `test` 指令会将 `CF`, `OF` 标志位清零

## 读取条件码

<!--sec data-title="SetX 指令的具体内容" data-id="section20210414121321" data-show=true data-collapse=true ces-->

| SetX    | Condition        | Description              |
|:-------:|:----------------:|:------------------------:|
| `sete`  | `ZF`             | Equal / Zero             |
| `setne` | `~ZF`            | Not Equal / Not Zero     |
| `sets`  | `SF`             | Negative                 |
| `setns` | `~SF`            | Nonnegative              |
| `setg`  | `~(SF^OF) & ~ZF` | Greater(Signed)          |
| `setge` | `~(SF^OF)`      | Greater or Equal(Signed) |
| `setl`  | `(SF^OF)`       | Less (Signed)            |
| `setle` | `(SF^OF) $|$ZF`    | Less or Equal(Signed)    |
| `seta`  | `~CF&~ZF`        | Above (unsigned)         |
| `setb`  | `CF`             | Below (unsigned)         |

<!--endsec-->


* SetX 指令的操作
  * 读取当前的条件码（或者某些条件码的组合)，并存入目的**字节**寄存器
    * 余下的三个字节不会修改
      * ![20210414121449-2021-04-14-12-14-49](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414121449-2021-04-14-12-14-49.png)
    * 通常会使用 `movzbl` 指令对目的寄存器进行 `0` 扩展

  <!--sec data-title="示例" data-id="section20210414122514" data-show=true data-collapse=true ces-->
  * C 代码

    ```c
    int gt(int x, int y)
    {
      return x > y;
    }
    
    ```

  * 汇编码

    ```nasm
    movl  12(%ebp), %eax  # eax = y
    cmpl  %eax, 8(%ebp)   # Compare x, y
    setg  %al             # al = x > y
    movzbl  %al, %eax     # Zero rest of %eax, 程序会返加 %eax 中的值
    ```
  <!--endsec-->

#### x86-64 下的读取条件码

* SetX 指令的操作
  * 读取当前的条件码（或者某些条件码的组合)，并存入目的**字节**寄存器
  * 寄存器中的余下 7 个字节不会被更改

<!--sec data-title="示例" data-id="section20210414123234" data-show=true data-collapse=true ces-->

* C 代码

  ```c
  long lgt(long x, long y)
  {
    return x > y;
  }
  ```

* 汇编码

  ```nasm
  xorl  %eax, %eax  # eax=0
  cmpq  %rsi, %rdi  # Compare x:y
  setg  %al         # al = x > y
  ```

  * 可以看出汇编码中只对 `%eax` 进行了处理， 即 `%rax` 的高 32 位
    * ![20210414124855-2021-04-14-12-48-55](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414124855-2021-04-14-12-48-55.png)
    * 这是因为技术手册中规定如果 32 位的运算产生了32位的结果，则自动的在目标通用寄存器的高 32 位进行零扩展
      <!-- TODO:数据项依赖的具体含义，为何这样做可又消除数据项依赖-->
      * 部分原因来自于微体系结构内部实现的效率方面的考虑，目的是为了消除“部分数据依赖”
<!--endsec-->

## 跳转指令

<!--sec data-title="指令的具体内容" data-id="section20210414162309" data-show=true data-collapse=true ces-->

| jX    | Condition        | Description              |
|:-------:|:----------------:|:------------------------:|
| `je`  | `ZF`             | Equal / Zero             |
| `jne` | `~ZF`            | Not Equal / Not Zero     |
| `js`  | `SF`             | Negative                 |
| `jns` | `~SF`            | Nonnegative              |
| `jg`  | `~(SF^OF) & ~ZF` | Greater(Signed)          |
| `jge` | `~(SF^OF)`      | Greater or Equal(Signed) |
| `jl`  | `(SF^OF)`       | Less (Signed)            |
| `jle` | `(SF^OF) $|$ZF`    | Less or Equal(Signed)    |
| `ja`  | `~CF&~ZF`        | Above (unsigned)         |
| `jb`  | `CF`             | Below (unsigned)         |

<!--endsec-->

* `jx`
  * 依赖当前的条件码选择下一条执行语句（是否顺序执行）

<!--sec data-title="跳转指令的实例" data-id="section20210414162657" data-show=true data-collapse=true ces-->
* C 代码与汇编代码
  * ![20210414162731-2021-04-14-16-27-31](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414162731-2021-04-14-16-27-31.png)
  * gcc-4.8 下没有摸索出如何编译出这种汇编代码，只有加上 `-march=i386` 才可以得到类似的结果，不然出来的是条件传送指令 `cmovC`
* 汇编代码与 C 代码原始的 "goto" 模式类似
  * ![20210414162748-2021-04-14-16-27-48](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414162748-2021-04-14-16-27-48.png)
* 也与 C 语言的条件表达式类似
  * ![20210414163307-2021-04-14-16-33-08](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414163307-2021-04-14-16-33-08.png)
<!--endsec-->

### 微体系结构背景

* 同时运行五条指令
  * 相当于工厂流水线

* 一般不会超过 20 段
  * 条件跳转指令会影响流水线
  * 会出现性能损失，需要尽可能的消除

## 条件传送指令

* `cmovC src, dest`
  * 如果条件 C 成立，将数据从 `src` 传送至 `dest`
  * 从执行的角度看，比一般的条件跳转指令的效率高
    * 因为其控制流可预测，不会出现跳转执行的情况

<!--sec data-title="条件传送指令实例" data-id="section20210414164704" data-show=true data-collapse=true ces-->

* x86-64 下对于 `absdiff` 来说，会用条件传送指令来替换条件跳转指令
  ![20210414165210-2021-04-14-16-52-10](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414165210-2021-04-14-16-52-10.png)
* 在 `-m32` 编译选项下，如果加上 `-march=i686` 选项，也可编译出采用条件传送指令的汇编代码
  * ![20210414165434-2021-04-14-16-54-34](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414165434-2021-04-14-16-54-34.png)

<!--endsec-->

### 局限性

* 两个分支有 "副作用"
* 表达式的计算量比较大

## 循环语句

* 所有的循环模式 (while, do-while, for) 都转换为 "do-while" 形式
* 历史上gee采用过多种转换模式，经历了 "否定之否定" 的过程

### do-while 形式

### Jump-to-Middle 模式

### 微体系结构背景

* 通过猜测来看是否跳转

## Switch 语句

* 跳转表 Jump Table
  * 表结构
  * 表项内容
* 指令段

* case 值很稀疏
  * 转换为 `if-then-else` 语句
  * 以二叉树的结构组织
    * 使得判断次数最少
